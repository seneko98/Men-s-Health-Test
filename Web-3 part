
import logging
import time
import random
import math
import asyncio
import traceback
from datetime import datetime, timedelta
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ConversationHandler, ContextTypes, CallbackQueryHandler
from telegram.error import TimedOut, NetworkError
try:
   import pymongo
   from bson import ObjectId
   MONGODB_AVAILABLE = True
except ImportError:
   MONGODB_AVAILABLE = False
   print("MongoDB support disabled - running in demo mode")

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(
   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
   level=logging.INFO,
   filename='bot_log.txt'
)
logger = logging.getLogger(__name__)

# –î—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–∏–π –∫–æ–¥
print("=" * 50)
print("–ó–ê–ü–£–°–ö MEN'S HEALTH TEST BOT –ó –Ü–ù–¢–ï–ì–†–ê–¶–Ü–Ñ–Æ SOLANA")
print("Mode: Demo (No MongoDB required)")
print("Web3 Features: Enabled (Solana DevNet)")
print("=" * 50)

# –¢–æ–∫–µ–Ω –±–æ—Ç–∞
TOKEN = "7773048753:AAG2gvPbz1sVqDXr_UjWBUonyFMIJyaarRA"  # –ó–∞–º—ñ–Ω—ñ—Ç—å –Ω–∞ –≤–∞—à —Ç–æ–∫–µ–Ω
MONGODB_URL = None  # –ù–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ MongoDB —É –¥–µ–º–æ-—Ä–µ–∂–∏–º—ñ

# –°—Ç–∞–Ω–∏ –¥–ª—è ConversationHandler
(NAME, AGE, GENDER, BODY_TYPE, HEIGHT, WEIGHT, QUESTIONS, PROCESSING, RESULTS, HORMONE_MENU,
WALLET_VERIFICATION, WALLET_ADDRESS, WALLET_SIGNATURE, WALLET_CONFIRMATION) = range(14)

# –î–æ–¥–∞—î–º–æ –º–æ–∫–∏ –¥–ª—è —Ä–æ–±–æ—Ç–∏ –±–µ–∑ MongoDB
class MockDBCollection:
   """Mock –¥–ª—è MongoDB –∫–æ–ª–µ–∫—Ü—ñ—ó –¥–ª—è –¥–µ–º–æ-–≤–µ—Ä—Å—ñ—ó –±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ—ó –±–∞–∑–∏ –¥–∞–Ω–∏—Ö"""
   def __init__(self):
       self.data = {}

   def find_one(self, query):
       user_id = query.get('user_id')
       if user_id and user_id in self.data:
           return self.data[user_id]
       return None

   def update_one(self, query, update, upsert=False):
       user_id = query.get('user_id')
       if user_id:
           if user_id not in self.data and upsert:
               self.data[user_id] = {'user_id': user_id}

           if user_id in self.data:
               # –û–±—Ä–æ–±–∫–∞ $set
               if '$set' in update:
                   for key, value in update['$set'].items():
                       self.data[user_id][key] = value

               # –û–±—Ä–æ–±–∫–∞ $push
               if '$push' in update:
                   for key, value in update['$push'].items():
                       if key not in self.data[user_id]:
                           self.data[user_id][key] = []
                       self.data[user_id][key].append(value)

               return MockUpdateResult(1)
       return MockUpdateResult(0)

   def update_many(self, query, update, upsert=False):
       # –î–ª—è –¥–µ–º–æ –ø—Ä–æ—Å—Ç–æ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑ 0 –º–æ–¥–∏—Ñ—ñ–∫–æ–≤–∞–Ω–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤
       return MockUpdateResult(0)

   def insert_one(self, document):
       user_id = document.get('user_id')
       if user_id:
           self.data[user_id] = document
           return MockInsertOneResult()
       return None

   def delete_many(self, query):
       # –î–ª—è –¥–µ–º–æ –ø—Ä–æ—Å—Ç–æ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑ 0 –≤–∏–¥–∞–ª–µ–Ω–∏—Ö –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤
       return MockDeleteResult(0)

class MockUpdateResult:
   def __init__(self, count):
       self.modified_count = count

class MockInsertOneResult:
   def __init__(self):
       self.inserted_id = "mock_id"

class MockDeleteResult:
   def __init__(self, count):
       self.deleted_count = count

###########################################
# Part 1: Solana Integration
###########################################

class PublicKey:
   """Stub for PublicKey class from Solana"""
   def __init__(self, value=None):
       self.value = value

   def __str__(self):
       return f"PublicKey({self.value})"

   @staticmethod
   def find_program_address(seeds, program_id):
       """Simulation of program address finding"""
       return PublicKey(f"simulated_pda_for_{seeds}"), 255

class Client:
   """Stub for Client class from Solana"""
   def __init__(self, url=None):
       self.url = url

   def get_account_info(self, pubkey):
       """Simulation of getting account info"""
       return {"result": {"value": None}}

class SolanaIntegration:
   def __init__(self):
       """Initialization of Solana integration"""
       try:
           # Using devnet for development
           self.client = Client("https://api.devnet.solana.com")
           self.admin_public_key = "DKCejcctpyK4ivM3yQ1E13qSYnrbUej1KoxeYf3jwZQg"  # Your pubkey
           self.enabled = True  # Is integration active
           logger.info("Solana integration initialized with devnet (simulation mode)")
       except Exception as e:
           logger.error(f"Error initializing Solana integration: {e}", exc_info=True)
           self.enabled = False
           logger.info("Solana integration disabled due to initialization error")

   async def verify_wallet_ownership(self, wallet_address, transaction_reference=None, verification_amount=None):
       """Verification of wallet ownership via test transaction"""
       try:
           if not self.enabled:
               logger.info(f"Wallet verification skipped (integration disabled)")
               return True, "Wallet verification successful (integration disabled)"

           # –°–∏–º—É–ª—é—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É —Ç–µ—Å—Ç–æ–≤–æ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó –¥–ª—è —Ö–∞–∫–∞—Ç–æ–Ω—É
           logger.info(f"Simulating wallet verification for: {wallet_address}")

           # –î–æ–¥–∞—î–º–æ –∑–∞—Ç—Ä–∏–º–∫—É –¥–ª—è —ñ–º—ñ—Ç–∞—Ü—ñ—ó –º–µ—Ä–µ–∂–µ–≤–æ–≥–æ –∑–∞–ø–∏—Ç—É
           await asyncio.sleep(0.2)

           # –î–ª—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä—ñ—à–µ–Ω–Ω—è —Ç—É—Ç –±—É–¥–µ –∫–æ–¥ –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
           # –ù–∞–ø—Ä–∏–∫–ª–∞–¥:
           # transaction = await self.client.get_transaction(transaction_reference)
           # if transaction and transaction.sender == wallet_address and abs(transaction.amount - verification_amount) < 0.0000001:
           #     return True, "Wallet verification successful"
           # else:
           #     return False, "Transaction verification failed"

           # –î–ª—è —Ö–∞–∫–∞—Ç–æ–Ω—É –ø—Ä–æ—Å—Ç–æ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ —É—Å–ø—ñ—Ö
           return True, f"Wallet verification successful via test transaction (development mode)"
       except Exception as e:
           logger.error(f"Wallet verification failed: {e}", exc_info=True)
           return False, f"Verification failed: {str(e)}"

   async def send_bonus_tokens(self, recipient_wallet, token_amount=10):
       """Sending bonus tokens to new user (simulation)"""
       try:
           if not self.enabled:
               logger.info(f"Token sending skipped (integration disabled)")
               return True, f"Tokens sent successfully (integration disabled)"

           # Just simulating sending for now
           logger.info(f"Simulating sending {token_amount} tokens to {recipient_wallet}")

           # –î–æ–¥–∞—î–º–æ –∑–∞—Ç—Ä–∏–º–∫—É –¥–ª—è —ñ–º—ñ—Ç–∞—Ü—ñ—ó –º–µ—Ä–µ–∂–µ–≤–æ–≥–æ –∑–∞–ø–∏—Ç—É
           await asyncio.sleep(0.2)

           # Later we'll replace with real token sending
           return True, f"Successfully sent {token_amount} tokens (development mode)"
       except Exception as e:
           logger.error(f"Failed to send bonus tokens: {e}", exc_info=True)
           return False, f"Failed to send tokens: {str(e)}"

###########################################
# Part 2: On-Chain Results Storage
###########################################

# Configuration
HEALTH_TEST_PROGRAM_ID = "Your_Future_Program_ID"  # Will be replaced after contract deployment

class OnChainResults:
   def __init__(self, solana_integration):
       """Initialization with existing Solana integration"""
       try:
           self.solana = solana_integration
           self.client = solana_integration.client
           self.enabled = solana_integration.enabled
           logger.info("OnChainResults initialized successfully")
       except Exception as e:
           logger.error(f"Error initializing OnChainResults: {e}", exc_info=True)
           self.enabled = False
           self.solana = solana_integration
           self.client = None
           logger.info("OnChainResults disabled due to initialization error")

   async def record_result_on_chain(self, user_id, test_results, user_wallet=None):
       """Records health test result on blockchain (simulation)"""
       try:
           if not self.enabled:
               logger.info("On-chain recording skipped (integration disabled)")
               return False, "Blockchain integration is disabled"

           # Simulating blockchain recording
           logger.info(f"Simulating on-chain health test recording for user {user_id}")

           # –î–æ–¥–∞—î–º–æ –∑–∞—Ç—Ä–∏–º–∫—É –¥–ª—è —ñ–º—ñ—Ç–∞—Ü—ñ—ó –º–µ—Ä–µ–∂–µ–≤–æ–≥–æ –∑–∞–ø–∏—Ç—É
           await asyncio.sleep(0.3)

           # Generate fake transaction hash
           simulated_tx_hash = f"simu1ated{user_id}{int(datetime.now().timestamp())}"
           simulated_address = f"healthresult{user_id}"

           return True, {
               "transaction_hash": simulated_tx_hash,
               "result_address": simulated_address,
               "simulation_mode": True
           }
       except Exception as e:
           logger.error(f"Failed to record result on-chain: {e}", exc_info=True)
           return False, f"Error recording result: {str(e)}"

   async def verify_result_on_chain(self, user_id):
       """Verifies result existence on blockchain (simulation)"""
       try:
           if not self.enabled:
               logger.info("On-chain verification skipped (integration disabled)")
               return False, "Blockchain integration is disabled"

           # Simulating blockchain verification
           logger.info(f"Simulating on-chain health test verification for user {user_id}")

           # –î–æ–¥–∞—î–º–æ –∑–∞—Ç—Ä–∏–º–∫—É –¥–ª—è —ñ–º—ñ—Ç–∞—Ü—ñ—ó –º–µ—Ä–µ–∂–µ–≤–æ–≥–æ –∑–∞–ø–∏—Ç—É
           await asyncio.sleep(0.2)

           return True, {
               "user_id": str(user_id),
               "timestamp": int(datetime.now().timestamp()),
               "simulation_mode": True
           }
       except Exception as e:
           logger.error(f"Error verifying result on-chain: {e}", exc_info=True)
           return False, f"Error verifying result: {str(e)}"

###########################################
# Part 3: Token System
###########################################

class TokenSystem:
   def __init__(self, db=None):
       """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–æ–∫–µ–Ω —Å–∏—Å—Ç–µ–º–∏ (–¥–µ–º–æ-—Ä–µ–∂–∏–º)"""
       try:
           self.db = db
           self.users = db.users if db else None
           self.user_balances = {}  # –õ–æ–∫–∞–ª—å–Ω–µ –∑–±–µ—Ä—ñ–≥–∞–Ω–Ω—è –±–∞–ª–∞–Ω—Å—ñ–≤ –¥–ª—è –¥–µ–º–æ
           logger.info("Token system initialized in demo mode")
       except Exception as e:
           logger.error(f"Error initializing TokenSystem: {e}", exc_info=True)
           self.users = None
           logger.info("TokenSystem initialized with potential issues")

   async def add_tokens(self, user_id, amount, reason="admin"):
       """–î–æ–¥–∞–≤–∞–Ω–Ω—è —Ç–æ–∫–µ–Ω—ñ–≤ –¥–æ –±–∞–ª–∞–Ω—Å—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ (–¥–µ–º–æ-—Ä–µ–∂–∏–º)"""
       try:
           # –û—Ç—Ä–∏–º—É—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π –±–∞–ª–∞–Ω—Å
           current_balance = self.user_balances.get(user_id, 0)
           new_balance = current_balance + amount

           # –û–Ω–æ–≤–ª—é—î–º–æ –±–∞–ª–∞–Ω—Å
           self.user_balances[user_id] = new_balance

           logger.info(f"Added {amount} tokens to user {user_id}. New balance: {new_balance}")
           return True, new_balance

       except Exception as e:
           logger.error(f"Error adding tokens: {e}", exc_info=True)
           return False, f"Error: {str(e)}"

   async def use_tokens(self, user_id, amount, feature):
       """–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ç–æ–∫–µ–Ω—ñ–≤ –¥–ª—è –ø—Ä–µ–º—ñ—É–º-—Ñ—É–Ω–∫—Ü—ñ–π (–¥–µ–º–æ-—Ä–µ–∂–∏–º)"""
       try:
           # –û—Ç—Ä–∏–º—É—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π –±–∞–ª–∞–Ω—Å
           current_balance = self.user_balances.get(user_id, 0)

           # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ —Ç–æ–∫–µ–Ω—ñ–≤
           if current_balance < amount:
               logger.warning(f"Insufficient tokens: User {user_id} has only {current_balance} tokens, needed {amount}")
               return False, f"Insufficient tokens: you have {current_balance}, needed {amount}"

           # –û–Ω–æ–≤–ª—é—î–º–æ –±–∞–ª–∞–Ω—Å
           new_balance = current_balance - amount
           self.user_balances[user_id] = new_balance

           logger.info(f"User {user_id} spent {amount} tokens on {feature}. New balance: {new_balance}")
           return True, new_balance

       except Exception as e:
           logger.error(f"Error using tokens: {e}", exc_info=True)
           return False, f"Error: {str(e)}"

   async def get_token_balance(self, user_id):
       """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –±–∞–ª–∞–Ω—Å—É —Ç–æ–∫–µ–Ω—ñ–≤ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ (–¥–µ–º–æ-—Ä–µ–∂–∏–º)"""
       try:
           return self.user_balances.get(user_id, 0)
       except Exception as e:
           logger.error(f"Error getting token balance: {e}", exc_info=True)
           return 0

###########################################
# Part 4: Update Schema
###########################################

def update_user_schema():
   """Mock –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ö–µ–º–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ - –¥–ª—è –¥–µ–º–æ-—Ä–µ–∂–∏–º—É"""
   logger.info("Mock update_user_schema called in demo mode")
   return True, "Demo mode: User schema would be updated in production"

def update_results_schema():
   """Mock –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ö–µ–º–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ - –¥–ª—è –¥–µ–º–æ-—Ä–µ–∂–∏–º—É"""
   logger.info("Mock update_results_schema called in demo mode")
   return True, "Demo mode: Results schema would be updated in production"

###########################################
# Part 5: HealthTestBot with Web3 Integration
###########################################

class HealthTestBot:
   def __init__(self, token, db_url=None):
       try:
           self.token = token
           self.client = None
           self.db = None
           self.users = MockDBCollection()  # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–∞–≥–ª—É—à–∫—É
           self.test_results = MockDBCollection()  # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –∑–∞–≥–ª—É—à–∫—É
           self.bot = None  # –ë—É–¥–µ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø—ñ–∑–Ω—ñ—à–µ

           # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Web3 –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ–≤ (–±—É–¥—É—Ç—å –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ñ –ø—ñ–∑–Ω—ñ—à–µ)
           self.solana = None
           self.onchain_results = None
           self.token_system = None

           logger.info("Working in demo mode without MongoDB")
       except Exception as e:
           logger.error(f"Error in bot initialization: {e}", exc_info=True)
           raise

   def set_bot(self, bot):
       """–í—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –µ–∫–∑–µ–º–ø–ª—è—Ä–∞ –±–æ—Ç–∞ –ø—ñ—Å–ª—è –π–æ–≥–æ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è"""
       try:
           self.bot = bot

           # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î–º–æ Web3 –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∏
           self.solana = SolanaIntegration()
           self.onchain_results = OnChainResults(self.solana)
           self.token_system = TokenSystem(self.db)
           logger.info("Web3 components initialized successfully")
       except Exception as e:
           logger.error(f"Failed to initialize Web3 components: {e}", exc_info=True)
           # –°—Ç–≤–æ—Ä—é—î–º–æ –∑–∞–≥–ª—É—à–∫–∏, —â–æ–± –±–æ—Ç –º—ñ–≥ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –±–µ–∑ Web3
           if not self.solana:
               self.solana = SolanaIntegration()
               self.solana.enabled = False
           if not self.onchain_results:
               self.onchain_results = OnChainResults(self.solana)
               self.onchain_results.enabled = False
           if not self.token_system:
               self.token_system = TokenSystem(self.db)
           logger.info("Created fallback Web3 components")

   async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
       """–ü–æ—á–∞—Ç–æ–∫ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó –∑ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—î—é –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –≥–∞–º–∞–Ω—Ü—è"""
       print(f"START COMMAND RECEIVED FROM USER: {update.effective_user.id}")
       logger.info(f"Start command received from user: {update.effective_user.id}")

       user_id = update.effective_user.id
       logger.info(f"Start method called by user: {user_id}")

       try:
           # –û—á–∏—â–µ–Ω–Ω—è –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ—Ö –¥–∞–Ω–∏—Ö
           delete_time = datetime.now()

           self.users.update_many(
               {"user_id": user_id},
               {"$set": {"active": False, "deleted_at": delete_time}}
           )

           logger.info(f"Auto-reset for user {user_id}: marked inactive profile")

       except Exception as e:
           logger.error(f"Error during auto-reset in start command: {e}", exc_info=True)

       # –û—á–∏—â–∞—î–º–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
       context.user_data.clear()

       # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ username –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
       user = update.effective_user
       if user.username:
           context.user_data['username'] = user.username

       # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ Web3 –∞–∫—Ç–∏–≤–Ω–∞
       if hasattr(self, 'solana') and self.solana and self.solana.enabled:
           # –ü—Ä–æ–ø–æ–Ω—É—î–º–æ Web3 —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—é
           keyboard = [
               [InlineKeyboardButton("‚úÖ Connect Phantom Wallet (100 tokens bonus)", callback_data="connect_phantom")],
               [InlineKeyboardButton("‚è≠Ô∏è Continue without wallet", callback_data="skip_wallet")]
           ]
           reply_markup = InlineKeyboardMarkup(keyboard)

           await update.message.reply_text(
               "üåü *Special Offer!* üåü\n\n"
               "Connect your Phantom wallet and receive bonus tokens!\n"
               "These tokens can be used for premium features in the bot.\n\n"
               "What would you like to do?",
               reply_markup=reply_markup,
               parse_mode="Markdown"
           )
           return WALLET_VERIFICATION
       else:
           # –Ø–∫—â–æ Web3 —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞, –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –∑–≤–∏—á–∞–π–Ω–æ—ó —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó
           logger.info(f"Skipping wallet verification for user {user_id} - Solana integration disabled")
           return await self.start_registration_after_wallet(update, context)

   async def handle_wallet_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
       """–û–±—Ä–æ–±–∫–∞ –∫–æ–ª–±–µ–∫—ñ–≤ –¥–ª—è –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –≥–∞–º–∞–Ω—Ü—è —á–µ—Ä–µ–∑ —Ç–µ—Å—Ç–æ–≤—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é"""
       query = update.callback_query
       await query.answer()

       try:
           if query.data == "connect_phantom":
               # –ì–µ–Ω–µ—Ä—É—î–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω—É —Å—É–º—É –¥–ª—è –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ü—ñ–π–Ω–æ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
               user_id = update.effective_user.id
               verification_amount = 0.000001 + (user_id % 1000) / 100000000  # –£–Ω—ñ–∫–∞–ª—å–Ω–∞ —Å—É–º–∞ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
               context.user_data['verification_amount'] = verification_amount

               # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —á–∞—Å–æ–≤—É –º—ñ—Ç–∫—É –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏
               context.user_data['verification_timestamp'] = int(datetime.now().timestamp())

               # –û—Ç—Ä–∏–º—É—î–º–æ –∞–¥—Ä–µ—Å—É –¥–ª—è –ø—Ä–∏–π–æ–º—É —Ç–µ—Å—Ç–æ–≤–æ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó (–≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç—ñ —Ü–µ –±—É–≤ –±–∏ –≥–∞–º–∞–Ω–µ—Ü—å –≤–∞—à–æ–≥–æ —Å–µ—Ä–≤—ñ—Å—É)
               receiver_address = "DKCejcctpyK4ivM3yQ1E13qSYnrbUej1KoxeYf3jwZQg"  # –ê–¥—Ä–µ—Å–∞ –∑ –≤–∞—à–æ–≥–æ –∫–æ–¥—É
               context.user_data['receiver_address'] = receiver_address

               # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
               await query.message.reply_text(
                   "To verify your wallet ownership:\n\n"
                   "1. Open your Phantom wallet\n"
                   "2. Make sure you're in Devnet mode\n"
                   "3. Send your wallet address here"
               )
               return WALLET_ADDRESS
           elif query.data == "skip_wallet":
               await query.message.reply_text(
                   "You chose to continue without connecting a wallet.\n"
                   "You can always connect it later in the settings."
               )
               # –ó–∞–ø—É—Å–∫–∞—î–º–æ –∑–≤–∏—á–∞–π–Ω—É —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—é
               return await self.start_registration_after_wallet(update, context)
       except Exception as e:
           logger.error(f"Error in handle_wallet_callback: {e}", exc_info=True)
           # –£ —Ä–∞–∑—ñ –ø–æ–º–∏–ª–∫–∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –∑–≤–∏—á–∞–π–Ω–æ—ó —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó
           await query.message.reply_text(
               "An error occurred while connecting the wallet. Continuing without it."
           )
           return await self.start_registration_after_wallet(update, context)

   async def handle_wallet_address(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
       """–û–±—Ä–æ–±–∫–∞ –≤–≤–µ–¥–µ–Ω–æ—ó –∞–¥—Ä–µ—Å–∏ –≥–∞–º–∞–Ω—Ü—è —Ç–∞ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó –¥–ª—è —Ç–µ—Å—Ç–æ–≤–æ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó"""
       try:
           wallet_address = update.message.text.strip()
           context.user_data['wallet_address'] = wallet_address

           # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –º–∞—î –∞–¥—Ä–µ—Å–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç –¥–ª—è Solana (base58, 32-44 —Å–∏–º–≤–æ–ª–∏)
           if not (len(wallet_address) >= 32 and len(wallet_address) <= 44):
               await update.message.reply_text(
                   "‚ùå This doesn't look like a valid Solana wallet address.\n"
                   "Please check and try again, or choose 'Skip'."
               )
               keyboard = [
                   [InlineKeyboardButton("‚è≠Ô∏è Continue without wallet", callback_data="skip_wallet")]
               ]
               reply_markup = InlineKeyboardMarkup(keyboard)
               await update.message.reply_text("Or skip this step:", reply_markup=reply_markup)
               return WALLET_ADDRESS

           # –ì–µ–Ω–µ—Ä—É—î–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω—É —Å—É–º—É –¥–ª—è –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ü—ñ—ó (–º–æ–∂–Ω–∞ –≤–∑—è—Ç–∏ –∑ context.user_data)
           verification_amount = context.user_data.get('verification_amount', 0.000001)
           receiver_address = context.user_data.get('receiver_address', "DKCejcctpyK4ivM3yQ1E13qSYnrbUej1KoxeYf3jwZQg")

           # –ü–æ–≤—ñ–¥–æ–º–ª—è—î–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –ø—Ä–æ –Ω–µ–æ–±—Ö—ñ–¥–Ω—ñ—Å—Ç—å –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ —Ç–µ—Å—Ç–æ–≤–æ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
           await update.message.reply_text(
               f"Wallet address received: `{wallet_address}`\n\n"
               f"To verify ownership, please send a TEST transaction to:\n"
               f"`{receiver_address}`\n\n"
               f"Amount: `{verification_amount:.8f}` SOL\n\n"
               f"After sending the transaction, type 'Done' or send the transaction hash.",
               parse_mode="Markdown"
           )

           # –î–æ–¥–∞—Ç–∫–æ–≤—ñ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Ç–µ—Å—Ç–æ–≤–∏—Ö SOL
           await update.message.reply_text(
               "If you don't have test SOL, you can get some from Solana Devnet Faucet:\n"
               "https://solfaucet.com/"
           )

           return WALLET_SIGNATURE  # –¢–µ–ø–µ—Ä —Ü–µ –±—É–¥–µ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó, –∞ –Ω–µ –ø—ñ–¥–ø–∏—Å
       except Exception as e:
           logger.error(f"Error in handle_wallet_address: {e}", exc_info=True)
           await update.message.reply_text(
               "An error occurred while processing the wallet address. Continuing without connection."
           )
           return await self.start_registration_after_wallet(update, context)

   async def verify_transaction(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
       """–û–±—Ä–æ–±–∫–∞ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è —Ç–µ—Å—Ç–æ–≤–æ—ó —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó –∑–∞–º—ñ—Å—Ç—å –ø—ñ–¥–ø–∏—Å—É"""
       try:
           user_message = update.message.text.strip()
           wallet_address = context.user_data.get('wallet_address')

           # –î–ª—è —Ö–∞–∫–∞—Ç–æ–Ω—É –º–∏ –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–π–º–∞—î–º–æ –±—É–¥—å-—è–∫–µ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è
           # –í —Ä–µ–∞–ª—å–Ω–æ–º—É –¥–æ–¥–∞—Ç–∫—É –º–∏ –± –ø–µ—Ä–µ–≤—ñ—Ä—è–ª–∏ —Ö–µ—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
           is_verified = True
           message = "Test transaction verified"

           if user_message.lower() == "done" or len(user_message) > 30:  # –ü—Ä–æ—Å—Ç–∏–π —Ö–µ–≤—Ä—ñ—Å—Ç–∏—á–Ω–∏–π –ø—ñ–¥—Ö—ñ–¥
               # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—é —á–µ—Ä–µ–∑ SolanaIntegration
               is_verified, message = await self.solana.verify_wallet_ownership(
                   wallet_address,
                   user_message if len(user_message) > 30 else None,  # –ú–æ–∂–ª–∏–≤–∏–π —Ö–µ—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
                   context.user_data.get('verification_amount')
               )

           if is_verified:
               # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –≥–∞–º–∞–Ω–µ—Ü—å —É –ø—Ä–æ—Ñ—ñ–ª—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
               context.user_data['wallet_verified'] = True
               context.user_data['verified_wallet'] = wallet_address

               user_id = update.effective_user.id
               bonus_amount = 100  # –ö—ñ–ª—å–∫—ñ—Å—Ç—å –±–æ–Ω—É—Å–Ω–∏—Ö —Ç–æ–∫–µ–Ω—ñ–≤

               await update.message.reply_text(
                   "üéâ Congratulations! Your wallet has been successfully verified!\n\n"
                   f"You will receive {bonus_amount} bonus tokens after completing registration!\n\n"
                   "Now let's continue with registration."
               )

               # –ü–µ—Ä–µ—Ö–æ–¥–∏–º–æ –¥–æ –∑–≤–∏—á–∞–π–Ω–æ—ó —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó
               return await self.start_registration_after_wallet(update, context)
           else:
               await update.message.reply_text(
                   "‚ùå Could not verify the transaction. Possible reasons:\n"
                   "- Transaction not yet confirmed on the network\n"
                   "- Wrong amount sent\n"
                   "- Transaction sent from another wallet\n\n"
                   "Would you like to try again or continue without a wallet?"
               )
               keyboard = [
                   [InlineKeyboardButton("üîÑ Try again", callback_data="connect_phantom")],
                   [InlineKeyboardButton("‚è≠Ô∏è Continue without wallet", callback_data="skip_wallet")]
               ]
               reply_markup = InlineKeyboardMarkup(keyboard)
               await update.message.reply_text("What would you like to do?", reply_markup=reply_markup)
               return WALLET_VERIFICATION
       except Exception as e:
           logger.error(f"Error in verify_transaction: {e}", exc_info=True)
           await update.message.reply_text(
               "An error occurred during transaction verification. Continuing without wallet connection."
           )
           return await self.start_registration_after_wallet(update, context)

   async def start_registration_after_wallet(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
       """–ü–æ—á–∏–Ω–∞—î–º–æ –∑–≤–∏—á–∞–π–Ω—É —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—é –ø—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ—ó –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ü—ñ—ó –≥–∞–º–∞–Ω—Ü—è"""
       try:
           # –ü—Ä–∏–≤—ñ—Ç–∞–ª—å–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
           await update.message.reply_text(
               f"Welcome to *Men's Health Test Bot* üß¨\n\n"
               f"This test is based on Dr. Braverman's methodology and includes an analysis of neurotransmitters and hormonal profile.\n\n"
               f"I will help you assess the state of key neurochemical systems that affect your well-being, sleep, mood, energy, and cognitive abilities.\n\n"
               f"After completing the test, you will receive:\n"
               f"‚Ä¢ Complete neurochemical profile üß†\n"
               f"‚Ä¢ Detailed analysis of each neurotransmitter and its level\n"
               f"‚Ä¢ Personalized recommendations for balance optimization üí™\n"
               f"‚Ä¢ Understanding of the relationship between lifestyle and brain biochemistry\n\n"
               f"To get the most accurate results, please answer the questions as honestly as possible.\n\n"
               f"Let's start!",
               parse_mode='Markdown'
           )

           # –ü–∏—Ç–∞—î–º–æ —ñ–º'—è
           await update.message.reply_text(
               "What is your name?",
               reply_markup=ReplyKeyboardRemove()
           )

           return NAME
       except Exception as e:
           logger.error(f"Error in start_registration_after_wallet: {e}", exc_info=True)
           # –Ø–∫—â–æ —Å—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞, –≤—Å–µ –æ–¥–Ω–æ –ø—Ä–æ–±—É—î–º–æ –ø–æ—á–∞—Ç–∏ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—é
           await update.message.reply_text(
               "An error occurred, but let's continue with registration.\n"
               "What is your name?",
               reply_markup=ReplyKeyboardRemove()
           )
           return NAME

   async def handle_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
       try:
           context.user_data['name'] = update.message.text
           logger.info(f"User {update.effective_user.id} provided name: {context.user_data['name']}")

           # –ü–∏—Ç–∞—î–º–æ –ø—Ä–æ –≤—ñ–∫
           keyboard = [
               ["Under 25", "25-35"],
               ["36-45", "46-60"],
               ["60+"]
           ]
           await update.message.reply_text(
               f"Nice to meet you, {context.user_data['name']}! Please indicate your age:",
               reply_markup=ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
           )

           return AGE
       except Exception as e:
           logger.error(f"Error in handle_name: {e}", exc_info=True)
           await update.message.reply_text("An error occurred. Please try again /start")
           return ConversationHandler.END

   async def handle_age(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
       try:
           context.user_data['age'] = update.message.text
           logger.info(f"User {update.effective_user.id} provided age: {context.user_data['age']}")

           # –ü–∏—Ç–∞—î–º–æ –ø—Ä–æ —Å—Ç–∞—Ç—å
           keyboard = [["Male", "Female"]]
           await update.message.reply_text(
               "Please indicate your gender:",
               reply_markup=ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
           )

           return GENDER
       except Exception as e:
           logger.error(f"Error in handle_age: {e}", exc_info=True)
           await update.message.reply_text("An error occurred. Please try again /start")
           return ConversationHandler.END

   async def handle_gender(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
       try:
           context.user_data['gender'] = update.message.text
           logger.info(f"User {update.effective_user.id} provided gender: {context.user_data['gender']}")

           # –ü–∏—Ç–∞—î–º–æ –ø—Ä–æ —Ç–∏–ø —Å—Ç–∞—Ç—É—Ä–∏
           keyboard = [
               ["Full", "Average"],
               ["Athletic", "Slim"]
           ]
           await update.message.reply_text(
               "What is your body type?",
               reply_markup=ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
           )

           return BODY_TYPE
       except Exception as e:
           logger.error(f"Error in handle_gender: {e}", exc_info=True)
           await update.message.reply_text("An error occurred. Please try again /start")
           return ConversationHandler.END

   async def handle_body_type(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
       try:
           context.user_data['body_type'] = update.message.text
           logger.info(f"User {update.effective_user.id} provided body type: {context.user_data['body_type']}")

           # –ü–∏—Ç–∞—î–º–æ –ø—Ä–æ –∑—Ä—ñ—Å—Ç
           await update.message.reply_text(
               "Please enter your height in centimeters (e.g., 175):",
               reply_markup=ReplyKeyboardRemove()
           )

           return HEIGHT
       except Exception as e:
           logger.error(f"Error in handle_body_type: {e}", exc_info=True)
           await update.message.reply_text("An error occurred. Please try again /start")
           return ConversationHandler.END

   async def handle_height(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
       try:
           height = int(update.message.text)
           if height < 50 or height > 250:
               await update.message.reply_text("Please enter a valid height in centimeters (e.g., 175):")
               return HEIGHT

           context.user_data['height'] = height
           logger.info(f"User {update.effective_user.id} provided height: {height} cm")

           # –ü–∏—Ç–∞—î–º–æ –ø—Ä–æ –≤–∞–≥—É
           await update.message.reply_text(
               "Please enter your weight in kilograms (e.g., 70):",
               reply_markup=ReplyKeyboardRemove()
           )

           return WEIGHT

       except ValueError:
           await update.message.reply_text("Please enter a number. What is your height in centimeters?")
           return HEIGHT
       except Exception as e:
           logger.error(f"Error in handle_height: {e}", exc_info=True)
           await update.message.reply_text("An error occurred. Please try again /start")
           return ConversationHandler.END

   async def handle_weight(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
       try:
           weight = float(update.message.text)
           if weight < 20 or weight > 300:
               await update.message.reply_text("Please enter a valid weight in kilograms (e.g., 70):")
               return WEIGHT

           context.user_data['weight'] = weight
           logger.info(f"User {update.effective_user.id} provided weight: {weight} kg")

           # –†–æ–∑—Ä–∞—Ö—É–≤–∞—Ç–∏ –Ü–ú–¢
           height = context.user_data['height']
           body_type = context.user_data['body_type']
           bmi = self.calculate_bmi(weight, height)
           bmi_category = self.get_bmi_category(bmi, body_type, weight)

           context.user_data['bmi'] = bmi
           context.user_data['bmi_category'] = bmi_category

           # –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø–µ—Ä–µ–¥ –ø–æ—á–∞—Ç–∫–æ–º —Ç–µ—Å—Ç—É –∑ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—î—é –ø—Ä–æ –Ü–ú–¢
           await update.message.reply_text(
               f"Thank you! Your Body Mass Index (BMI): *{bmi}* - *{bmi_category}*.\n\n"
               f"Now we will proceed to evaluate your neurotransmitter and hormonal profile.\n\n"
               f"I will ask a series of questions about your well-being, mood, energy, and cognitive functions. "
               f"Please answer as honestly as possible to get accurate results.",
               parse_mode='Markdown'
           )

           # –ó–∞—Ç—Ä–∏–º–∫–∞ –ø–µ—Ä–µ–¥ –ø–æ—á–∞—Ç–∫–æ–º —Ç–µ—Å—Ç—É –¥–ª—è –∫—Ä–∞—â–æ–≥–æ —Å–ø—Ä–∏–π–Ω—è—Ç—Ç—è
           time.sleep(1)

           # –î–ª—è —Ö–∞–∫–∞—Ç–æ–Ω—É –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ —Ä–µ–∞–ª—å–Ω—ñ –∑–∞–ø–∏—Ç–∞–Ω–Ω—è —ñ –≤—ñ–¥—Ä–∞–∑—É –ø–æ–∫–∞–∑—É—î–º–æ processing
           await update.message.reply_text(
               "üìä Starting neurochemical test...",
           )

           # –ü–µ—Ä–µ–π–¥–µ–º–æ –¥–æ –æ–±—Ä–æ–±–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
           return await self.process_results(update, context)

       except ValueError:
           await update.message.reply_text("Please enter a number. What is your weight in kilograms?")
           return WEIGHT
       except Exception as e:
           logger.error(f"Error in handle_weight: {e}", exc_info=True)
           await update.message.reply_text("An error occurred. Please try again /start")
           return ConversationHandler.END

   # –î–æ–¥–∞—î–º–æ –º–µ—Ç–æ–¥–∏ –¥–ª—è —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É –Ü–ú–¢
   def calculate_bmi(self, weight, height):
       try:
           # –í–∏—Å–æ—Ç–∞ –≤ –º–µ—Ç—Ä–∞—Ö (–ø—Ä–∏—Ö–æ–¥–∏—Ç—å –≤ —Å–º)
           height_m = height / 100
           # –§–æ—Ä–º—É–ª–∞ –Ü–ú–¢: –≤–∞–≥–∞ (–∫–≥) / –∑—Ä—ñ—Å—Ç¬≤ (–º)
           bmi = weight / (height_m * height_m)
           return round(bmi, 1)
       except Exception as e:
           logger.error(f"Error in calculate_bmi: {e}")
           return 0

   def get_bmi_category(self, bmi, body_type, weight):
       try:
           if body_type == "Athletic":
               if bmi < 18.5:
                   return "Underweight"
               elif bmi < 27:  # –†–æ–∑—à–∏—Ä–µ–Ω–∏–π –¥—ñ–∞–ø–∞–∑–æ–Ω –¥–ª—è —Å–ø–æ—Ä—Ç—Å–º–µ–Ω—ñ–≤
                   return "Normal weight"
               elif bmi < 30 or weight < 100:
                   return "Slight excess mass - may be related to muscle mass"
               else:
                   return "Excess weight - recommended to reduce"
           else:
               if bmi < 18.5:
                   return "Underweight"
               elif bmi < 25:
                   return "Normal weight"
               elif bmi < 30:
                   return "Overweight - weight loss recommended"
               else:
                   return "Obesity - weight loss necessary for health"
       except Exception as e:
           logger.error(f"Error in get_bmi_category: {e}")
           return "Unable to determine category"

   # –Ü–º—ñ—Ç–∞—Ü—ñ—è –æ–±—Ä–æ–±–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –∑ Web3 —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—î—é
   async def process_results(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
       try:
           await update.message.reply_text(
               "üß† *Test completed!* Starting analysis of your neurochemical and hormonal profile...",
               parse_mode='Markdown'
           )

           # –Ü–º—ñ—Ç—É—î–º–æ –ø—Ä–æ—Ü–µ—Å –æ–±—Ä–æ–±–∫–∏ –∑ –∫—ñ–ª—å–∫–æ–º–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏
           processing_phrases = [
               "Analyzing initial data...",
               "Evaluating neurotransmitter levels...",
               "Analyzing hormonal profile...",
               "Calculating correlations between different systems...",
               "Generating personalized recommendations...",
               "Preparing to store results on Solana blockchain..."
           ]

           for phrase in processing_phrases[:3]:
               time.sleep(random.uniform(1.0, 1.5))
               await update.message.reply_text(f"{phrase}")

           # –Ø–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –≤–µ—Ä–∏—Ñ—ñ–∫—É–≤–∞–≤ –≥–∞–º–∞–Ω–µ—Ü—å, –ø–æ–∫–∞–∑—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–æ –∑–∞–ø–∏—Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –≤ –±–ª–æ–∫—á–µ–π–Ω
           if context.user_data.get('wallet_verified'):
               time.sleep(1.5)
               await update.message.reply_text(
                   "üîó Preparing to record test results on Solana blockchain for immutability and verification..."
               )

               # –Ü–º—ñ—Ç—É—î–º–æ –∑–∞–ø–∏—Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –≤ –±–ª–æ–∫—á–µ–π–Ω
               user_id = update.effective_user.id
               wallet_address = context.user_data.get('verified_wallet')

               # –°—Ç–≤–æ—Ä—é—î–º–æ –º–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ —Ç–µ—Å—Ç—É
               test_results = {
                   "user_id": user_id,
                   "timestamp": datetime.now().isoformat(),
                   "bmi": context.user_data.get('bmi', 0),
                   "neurotransmitters": {
                       "serotonin": 65,
                       "dopamine": 78,
                       "acetylcholine": 55,
                       "gaba": 82,
                       "noradrenaline": 70
                   },
                   "hormones": {
                       "testosterone": 72,
                       "estradiol": 48,
                       "cortisol": 65
                   }
               }

               # –ó–∞–ø–∏—Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –≤ –±–ª–æ–∫—á–µ–π–Ω (—Å–∏–º—É–ª—è—Ü—ñ—è)
               success, result = await self.onchain_results.record_result_on_chain(
                   user_id,
                   test_results,
                   wallet_address
               )

               if success:
                   time.sleep(1.0)
                   await update.message.reply_text(
                       f"‚úÖ Test results successfully recorded on Solana blockchain!\n"
                       f"Transaction hash: `{result.get('transaction_hash')}`",
                       parse_mode="Markdown"
                   )

                   # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ö–µ—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó –¥–ª—è –ø–æ–¥–∞–ª—å—à–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
                   context.user_data['transaction_hash'] = result.get('transaction_hash')

                   # –ù–∞—Ä–∞—Ö—É–≤–∞–Ω–Ω—è –±–æ–Ω—É—Å–Ω–∏—Ö —Ç–æ–∫–µ–Ω—ñ–≤ –∑–∞ –ø—Ä–æ—Ö–æ–¥–∂–µ–Ω–Ω—è —Ç–µ—Å—Ç—É
                   bonus_amount = 50
                   token_success, balance = await self.token_system.add_tokens(
                       user_id,
                       bonus_amount,
                       "test_completion_bonus"
                   )

                   if token_success:
                       time.sleep(0.5)
                       await update.message.reply_text(
                           f"üéÅ You have been awarded {bonus_amount} tokens for completing the test!\n"
                           f"Current balance: {balance} tokens"
                       )

           # –î–æ–¥–∞—î–º–æ —â–µ –∫—ñ–ª—å–∫–∞ —Ñ—Ä–∞–∑ –æ–±—Ä–æ–±–∫–∏
           for phrase in processing_phrases[3:]:
               time.sleep(random.uniform(1.0, 1.5))
               await update.message.reply_text(f"{phrase}")

           # –ù–µ–≤–µ–ª–∏–∫–∞ –∑–∞—Ç—Ä–∏–º–∫–∞ –ø–µ—Ä–µ–¥ –ø–æ–∫–∞–∑–æ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
           time.sleep(1.0)

           # –ü–æ–∫–∞–∑—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
           return await self.show_results(update, context)
       except Exception as e:
           logger.error(f"Error in process_results: {e}", exc_info=True)
           await update.message.reply_text("An error occurred while processing results. Please try again /start")
           return ConversationHandler.END

   # –ü–æ–∫–∞–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ - —Ä–æ–∑–±–∏—Ç–∏–π –Ω–∞ –∫—ñ–ª—å–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
   async def show_results(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
       try:
           name = context.user_data.get('name', 'User')
           bmi = context.user_data.get('bmi', 0)
           bmi_category = context.user_data.get('bmi_category', 'Not defined')
           body_type = context.user_data.get('body_type', 'Not defined')

           # –°—Ç–≤–æ—Ä—é—î–º–æ –º–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –¥–ª—è —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è
           scores = {
               'serotonin': 65,
               'dopamine': 78,
               'acetylcholine': 55,
               'gaba': 82,
               'noradrenaline': 70,
               'testosterone': 72,
               'estradiol': 48,
               'cortisol': 65,
               'liver': 60,
               'sleep': 75
           }

           # –Ü–º—ñ—Ç—É—î–º–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ñ –±–∞–ª–∏ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø–æ–∫–∞–∑–Ω–∏–∫–∞
           max_scores = {key: 100 for key in scores}

           # –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è 1: –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞ –∞–Ω—Ç—Ä–æ–ø–æ–º–µ—Ç—Ä–∏—á–Ω—ñ –¥–∞–Ω—ñ
           result_text = f"üî¨ *NEUROCHEMICAL PROFILE RESULTS* üî¨\n\n"
           result_text += f"*{name}, here is your personalized analysis:*\n\n"
           result_text += f"*ANTHROPOMETRIC DATA:*\n"
           result_text += f"‚Ä¢ Body type: {body_type}\n"
           result_text += f"‚Ä¢ Body Mass Index (BMI): {bmi} - {bmi_category}\n\n"

           await update.message.reply_text(result_text, parse_mode='Markdown')

           # –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è 2: –ù–µ–π—Ä–æ–º–µ–¥—ñ–∞—Ç–æ—Ä–Ω–∏–π –ø—Ä–æ—Ñ—ñ–ª—å
           result_text = "*NEUROTRANSMITTER PROFILE:*\n\n"

           neurotransmitters = ['serotonin', 'dopamine', 'acetylcholine', 'gaba', 'noradrenaline']
           descriptions = {
               'serotonin': 'Regulates mood, sleep, appetite, feeling of satisfaction and social behavior',
               'dopamine': 'Responsible for motivation, reward, focus and ability to feel pleasure',
               'acetylcholine': 'Important for memory, learning, creativity and mental activity',
               'gaba': 'The main inhibitory neurotransmitter that provides calm, relaxation and sleep',
               'noradrenaline': 'Regulates energy, attention, reaction speed and ability to cope with stress'
           }

           for nt in neurotransmitters:
               percentage = scores.get(nt, 0)
               if percentage >= 75:
                   level = "üü¢ Excellent"
               elif percentage >= 50:
                   level = "üü° Normal"
               elif percentage >= 25:
                   level = "üü† Needs attention"
               else:
                   level = "üî¥ Critical"

               level_bar = "‚ñì" * int(percentage / 10) + "‚ñë" * (10 - int(percentage / 10))

               result_text += f"*{nt.capitalize()}*: {level}\n"
               result_text += f"{level_bar} {int(percentage)}%\n"
               result_text += f"_{descriptions.get(nt, 'No description available')}_\n\n"

           await update.message.reply_text(result_text, parse_mode='Markdown')

           # –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è 3: –ì–æ—Ä–º–æ–Ω–∞–ª—å–Ω–∏–π –ø—Ä–æ—Ñ—ñ–ª—å
           result_text = "*HORMONAL PROFILE:*\n\n"

           hormones = ['testosterone', 'estradiol', 'cortisol']
           hormone_descriptions = {
               'testosterone': 'Responsible for muscle mass, libido, energy, motivation and dominance',
               'estradiol': 'Regulates gender characteristics, reproductive function, mood and cognitive abilities',
               'cortisol': 'Regulates energy, stress response, immunity and inflammatory processes in the body'
           }

           for h in hormones:
               percentage = scores.get(h, 0)
               if percentage >= 75:
                   level = "üü¢ Excellent"
               elif percentage >= 50:
                   level = "üü° Normal"
               elif percentage >= 25:
                   level = "üü† Needs attention"
               else:
                   level = "üî¥ Critical"

               level_bar = "‚ñì" * int(percentage / 10) + "‚ñë" * (10 - int(percentage / 10))

               result_text += f"*{h.capitalize()}*: {level}\n"
               result_text += f"{level_bar} {int(percentage)}%\n"
               result_text += f"_{hormone_descriptions.get(h, 'No description available')}_\n\n"

           await update.message.reply_text(result_text, parse_mode='Markdown')

           # –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è 4: –°–∏—Å—Ç–µ–º–Ω–∏–π –ø—Ä–æ—Ñ—ñ–ª—å
           result_text = "*SYSTEM PROFILE:*\n\n"

           systems = ['liver', 'sleep']
           system_descriptions = {
               'liver': 'Responsible for blood purification, hormone processing, detoxification and metabolism of nutrients',
               'sleep': 'Provides recovery of the nervous system, tissue regeneration and hormone balancing'
           }

           for s in systems:
               percentage = scores.get(s, 0)
               if percentage >= 75:
                   level = "üü¢ Excellent"
               elif percentage >= 50:
                   level = "üü° Normal"
               elif percentage >= 25:
                   level = "üü† Needs attention"
               else:
                   level = "üî¥ Critical"

               level_bar = "‚ñì" * int(percentage / 10) + "‚ñë" * (10 - int(percentage / 10))

               result_text += f"*{s.capitalize()}*: {level}\n"
               result_text += f"{level_bar} {int(percentage)}%\n"
               result_text += f"_{system_descriptions.get(s, 'No description available')}_\n\n"

           await update.message.reply_text(result_text, parse_mode='Markdown')

           # –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è 5: –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó
           result_text = "*RECOMMENDATIONS:*\n\n"

           # –î–æ–¥–∞—î–º–æ –±–∞–∑–æ–≤—ñ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó –¥–ª—è —è–∫–æ–≥–æ—Å—å –Ω–µ–π—Ä–æ–º–µ–¥—ñ–∞—Ç–æ—Ä–∞ –∑ –Ω–∏–∑—å–∫–∏–º —Ä—ñ–≤–Ω–µ–º
           deficient_nt = 'acetylcholine'  # –ü—Ä–æ—Å—Ç–æ –¥–ª—è –ø—Ä–∏–∫–ª–∞–¥—É

           result_text += f"*FOR NEUROTRANSMITTER BALANCE:*\n"
           recommendations = [
               "Increase consumption of eggs, liver and vegetables",
               "Practice new skills and mental exercises",
               "Regularly read and solve puzzles",
               "Eggs, liver, lecithin, seafood",
               "Vitamins: B1, B5 (pantothenic acid), Omega-3"
           ]

           for i, recommendation in enumerate(recommendations):
               if i < 4:  # –ü–æ–∫–∞–∑—É—î–º–æ —Ç—ñ–ª—å–∫–∏ –ø–µ—Ä—à—ñ 4 —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó –≤ –±–∞–∑–æ–≤–æ–º—É –∑–≤—ñ—Ç—ñ
                   result_text += f"‚Ä¢ {recommendation}\n"

           result_text += "\n"

           # –î–æ–¥–∞—î–º–æ –±–∞–∑–æ–≤—ñ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó –¥–ª—è –≥–æ—Ä–º–æ–Ω—É
           deficient_hormone = 'testosterone'  # –ü—Ä–æ—Å—Ç–æ –¥–ª—è –ø—Ä–∏–∫–ª–∞–¥—É

           result_text += f"*FOR HORMONAL BALANCE:*\n"
           hormone_recommendations = [
               "Include strength training in your routine (3-4 times per week)",
               "Ensure proper sleep (7-8 hours)",
               "Enrich diet with zinc (pumpkin seeds, oysters) and magnesium",
               "Vitamin D3 (up to 4000 IU, especially in winter)",
               "Zinc (15-30 mg)",
               "Magnesium (citrate/glycinate)"
           ]

           for i, recommendation in enumerate(hormone_recommendations):
               if i < 4:  # –ü–æ–∫–∞–∑—É—î–º–æ —Ç—ñ–ª—å–∫–∏ –ø–µ—Ä—à—ñ 4 —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó –≤ –±–∞–∑–æ–≤–æ–º—É –∑–≤—ñ—Ç—ñ
                   result_text += f"‚Ä¢ {recommendation}\n"

           await update.message.reply_text(result_text, parse_mode='Markdown')

           # –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è 6: –§—ñ–Ω–∞–ª—å–Ω–∞ –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—è —Ç–∞ –∫–Ω–æ–ø–∫–∏
           premium_features_text = """
*PREMIUM FEATURES AVAILABLE WITH TOKENS:*

üî∏ Detailed results analysis stored on blockchain
üî∏ Extended recommendations program
üî∏ Weekly monitoring of your neurochemical profile
üî∏ Personal consultation with a specialist
"""

           # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î —É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≥–∞–º–∞–Ω–µ—Ü—å
           wallet_verified = context.user_data.get('wallet_verified', False)
           token_balance = 0

           # –û—Ç—Ä–∏–º—É—î–º–æ –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω—ñ–≤, —è–∫—â–æ –≥–∞–º–∞–Ω–µ—Ü—å –≤–µ—Ä–∏—Ñ—ñ–∫–æ–≤–∞–Ω–∏–π
           if wallet_verified:
               user_id = update.effective_user.id
               token_balance = await self.token_system.get_token_balance(user_id)

           if wallet_verified:
               result_text = f"*YOUR RESULTS ARE SAFELY STORED ON BLOCKCHAIN*\n\n"
               result_text += f"üìä Your results have been recorded on Solana blockchain for future reference and comparison.\n\n"
               result_text += f"üí∞ Your token balance: {token_balance} tokens\n\n"
               result_text += premium_features_text

               # –î–æ–¥–∞—î–º–æ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è —Ç–æ–∫–µ–Ω—ñ–≤
               keyboard = [
                   [InlineKeyboardButton("üìä Extended Analysis (50 tokens)", callback_data="extended_analysis")],
                   [InlineKeyboardButton("üß™ Recommended Tests (30 tokens)", callback_data="recommended_tests")],
                   [InlineKeyboardButton("üë®‚Äç‚öïÔ∏è Specialist Consultation", url="https://t.me/vladyslav_kravchukk")]
               ]
           else:
               result_text = "*CONNECT WALLET TO UNLOCK PREMIUM FEATURES*\n\n"
               result_text += "üîí Connect your wallet to store your results on blockchain and access premium features.\n\n"
               result_text += premium_features_text

               # –î–æ–¥–∞—î–º–æ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –≥–∞–º–∞–Ω—Ü—è
               keyboard = [
                   [InlineKeyboardButton("üîó Connect Wallet", callback_data="connect_phantom")],
                   [InlineKeyboardButton("üë®‚Äç‚öïÔ∏è Specialist Consultation", url="https://t.me/vladyslav_kravchukk")]
               ]

           reply_markup = InlineKeyboardMarkup(keyboard)

           # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Ñ—ñ–Ω–∞–ª—å–Ω–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ –∫–Ω–æ–ø–∫–∞–º–∏
           await update.message.reply_text(result_text, parse_mode='Markdown', reply_markup=reply_markup)

           # –Ø–∫—â–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –≤–µ—Ä–∏—Ñ—ñ–∫—É–≤–∞–≤ –≥–∞–º–∞–Ω–µ—Ü—å, –¥–æ–¥–∞—î–º–æ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø–µ—Ä–µ–≥–ª—è–¥—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó –≤ Solana Explorer
           if wallet_verified and context.user_data.get('transaction_hash'):
               # –û—Ç—Ä–∏–º—É—î–º–æ —Ö–µ—à —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó –∑ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ –∑–∞–ø–∏—Å—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
               tx_hash = context.user_data.get('transaction_hash')

               explorer_keyboard = [
                   [InlineKeyboardButton("üîç View Transaction in Solana Explorer", url=f"https://explorer.solana.com/tx/{tx_hash}?cluster=devnet")]
               ]
               explorer_markup = InlineKeyboardMarkup(explorer_keyboard)

               await update.message.reply_text(
                   "You can view your test results transaction on Solana Explorer:",
                   reply_markup=explorer_markup
               )

           return ConversationHandler.END
       except Exception as e:
           logger.error(f"Error in show_results: {e}", exc_info=True)
           await update.message.reply_text("An error occurred while displaying results. Please try again /start")
           return ConversationHandler.END

   async def handle_result_buttons(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
       """–û–±—Ä–æ–±–∫–∞ –Ω–∞—Ç–∏—Å–∫–∞–Ω—å –Ω–∞ –∫–Ω–æ–ø–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤"""
       try:
           query = update.callback_query
           await query.answer()

           if query.data == "extended_analysis":
               # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –±–∞–ª–∞–Ω—Å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
               user_id = update.effective_user.id
               token_balance = await self.token_system.get_token_balance(user_id)
               token_cost = 50

               if token_balance >= token_cost:
                   # –°–ø–∏—Å—É—î–º–æ —Ç–æ–∫–µ–Ω–∏
                   success, new_balance = await self.token_system.use_tokens(
                       user_id,
                       token_cost,
                       "extended_analysis"
                   )

                   if success:
                       await query.message.reply_text(
                           f"üîç *EXTENDED ANALYSIS PURCHASED*\n\n"
                           f"Your extended analysis is being generated and will be stored on the blockchain.\n\n"
                           f"üí∞ {token_cost} tokens have been deducted from your balance.\n"
                           f"Current balance: {new_balance} tokens",
                           parse_mode="Markdown"
                       )

                       # –Ü–º—ñ—Ç—É—î–º–æ –∑–∞–ø–∏—Å —Ä–æ–∑—à–∏—Ä–µ–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É –≤ –±–ª–æ–∫—á–µ–π–Ω
                       time.sleep(1.5)

                       # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Ä–æ–∑—à–∏—Ä–µ–Ω–æ–≥–æ –∞–Ω–∞–ª—ñ–∑—É
                       extended_analysis = """
*DETAILED NEUROTRANSMITTER AND HORMONE ANALYSIS*

*SEROTONIN: 65% (Normal)*
‚Ä¢ Moderate stress resilience
‚Ä¢ Good baseline mood with normal fluctuations
‚Ä¢ Normal sleep cycle with occasional disruptions
‚Ä¢ Recommended supplements: 5-HTP, Vitamin B6, Magnesium

*DOPAMINE: 78% (Good)*
‚Ä¢ Strong motivation and focus
‚Ä¢ Good reward response
‚Ä¢ Healthy pleasure appreciation
‚Ä¢ Recommended support: Regular exercise, Tyrosine-rich foods

*ACETYLCHOLINE: 55% (Needs attention)*
‚Ä¢ Slight memory and recall issues
‚Ä¢ Moderate learning efficiency
‚Ä¢ Good mental flexibility
‚Ä¢ Recommended: Alpha GPC, Huperzine A, Phosphatidylcholine

*GABA: 82% (Excellent)*
‚Ä¢ Excellent stress management
‚Ä¢ Good emotional control
‚Ä¢ Healthy sleep quality
‚Ä¢ No specific intervention needed

*NORADRENALINE: 70% (Normal)*
‚Ä¢ Appropriate energy levels
‚Ä¢ Normal stress response
‚Ä¢ Good alertness
‚Ä¢ Recommended: Regular interval training

*TESTOSTERONE: 72% (Good)*
‚Ä¢ Good muscle development potential
‚Ä¢ Healthy libido
‚Ä¢ Strong energy levels
‚Ä¢ Recommended: ZMA, Vitamin D3, Strength training

*ESTRADIOL: 48% (Needs attention)*
‚Ä¢ Slight hormonal imbalance
‚Ä¢ Moderate mood stability
‚Ä¢ Consider: DIM, Calcium D-Glucarate

*CORTISOL: 65% (Normal)*
‚Ä¢ Normal daily energy pattern
‚Ä¢ Appropriate stress response
‚Ä¢ Occasionally elevated evening levels
‚Ä¢ Recommended: Ashwagandha, Phosphatidylserine

üìä This analysis was verified and stored on the Solana blockchain for future reference and comparison.
"""
                       await query.message.reply_text(extended_analysis, parse_mode="Markdown")

                       # –Ü–º—ñ—Ç—É—î–º–æ –∑–∞–ø–∏—Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –≤ –±–ª–æ–∫—á–µ–π–Ω
                       tx_hash = f"simu1ated{user_id}extended{int(datetime.now().timestamp())}"

                       # –î–æ–¥–∞—î–º–æ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø–µ—Ä–µ–≥–ª—è–¥—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
                       explorer_keyboard = [
                           [InlineKeyboardButton("üîç View Extended Analysis Transaction", url=f"https://explorer.solana.com/tx/{tx_hash}?cluster=devnet")]
                       ]
                       explorer_markup = InlineKeyboardMarkup(explorer_keyboard)

                       await query.message.reply_text(
                           "‚úÖ Your extended analysis has been successfully stored on Solana blockchain!",
                           reply_markup=explorer_markup
                       )
                   else:
                       await query.message.reply_text(
                           f"‚ùå Failed to process tokens. Please try again later."
                       )
               else:
                   await query.message.reply_text(
                       f"‚ùå Insufficient tokens. You have {token_balance} tokens, but need {token_cost}.\n\n"
                       f"Consider connecting your wallet to receive bonus tokens."
                   )

           elif query.data == "recommended_tests":
               # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –±–∞–ª–∞–Ω—Å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
               user_id = update.effective_user.id
               token_balance = await self.token_system.get_token_balance(user_id)
               token_cost = 30

               if token_balance >= token_cost:
                   # –°–ø–∏—Å—É—î–º–æ —Ç–æ–∫–µ–Ω–∏
                   success, new_balance = await self.token_system.use_tokens(
                       user_id,
                       token_cost,
                       "recommended_tests"
                   )

                   if success:
                       await query.message.reply_text(
                           f"üß™ *RECOMMENDED TESTS PURCHASED*\n\n"
                           f"Your personalized test recommendations are being generated.\n\n"
                           f"üí∞ {token_cost} tokens have been deducted from your balance.\n"
                           f"Current balance: {new_balance} tokens",
                           parse_mode="Markdown"
                       )

                       # –Ü–º—ñ—Ç—É—î–º–æ –≥–µ–Ω–µ—Ä–∞—Ü—ñ—é —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ–π
                       time.sleep(1.5)

                       # –í—ñ–¥–ø—Ä–∞–≤–∫–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏—Ö —Ç–µ—Å—Ç—ñ–≤
                       recommended_tests = """
*RECOMMENDED LABORATORY TESTS*

Based on your neurochemical profile, we recommend the following laboratory tests:

*BASIC TESTS:*
‚Ä¢ Complete Blood Count (CBC)
‚Ä¢ Comprehensive Metabolic Panel (CMP)
‚Ä¢ Lipid Panel
‚Ä¢ HbA1c

*HORMONE PANEL:*
‚Ä¢ Total and Free Testosterone
‚Ä¢ Estradiol
‚Ä¢ SHBG (Sex Hormone Binding Globulin)
‚Ä¢ DHT (Dihydrotestosterone)
‚Ä¢ Prolactin
‚Ä¢ Cortisol (preferably 4-point saliva test)

*THYROID PANEL:*
‚Ä¢ TSH, Free T3, Free T4
‚Ä¢ Reverse T3
‚Ä¢ Thyroid Antibodies

*VITAMIN & MINERAL STATUS:*
‚Ä¢ Vitamin D - 25(OH)D
‚Ä¢ Vitamin B12 & Folate
‚Ä¢ Magnesium (RBC)
‚Ä¢ Zinc & Copper

*INFLAMMATION MARKERS:*
‚Ä¢ hsCRP
‚Ä¢ Homocysteine
‚Ä¢ Ferritin

These tests will provide comprehensive information about your metabolic, hormonal, and nutritional status, allowing for precise optimization of your health.

üìä This recommendation was stored on the Solana blockchain for future reference.
"""
                       await query.message.reply_text(recommended_tests, parse_mode="Markdown")

                       # –Ü–º—ñ—Ç—É—î–º–æ –∑–∞–ø–∏—Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –≤ –±–ª–æ–∫—á–µ–π–Ω
                       tx_hash = f"simu1ated{user_id}tests{int(datetime.now().timestamp())}"

                       # –î–æ–¥–∞—î–º–æ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø–µ—Ä–µ–≥–ª—è–¥—É —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ—ó
                       explorer_keyboard = [
                           [InlineKeyboardButton("üîç View Recommendation Transaction", url=f"https://explorer.solana.com/tx/{tx_hash}?cluster=devnet")]
                       ]
                       explorer_markup = InlineKeyboardMarkup(explorer_keyboard)

                       await query.message.reply_text(
                           "‚úÖ Your test recommendations have been successfully stored on Solana blockchain!",
                           reply_markup=explorer_markup
                       )
                   else:
                       await query.message.reply_text(
                           f"‚ùå Failed to process tokens. Please try again later."
                       )
               else:
                   await query.message.reply_text(
                       f"‚ùå Insufficient tokens. You have {token_balance} tokens, but need {token_cost}.\n\n"
                       f"Consider connecting your wallet to receive bonus tokens."
                   )

           elif query.data == "connect_phantom":
               # –ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è—î–º–æ –Ω–∞ –≤–µ—Ä–∏—Ñ—ñ–∫–∞—Ü—ñ—é –≥–∞–º–∞–Ω—Ü—è
               await query.message.reply_text(
                   "To connect your Phantom wallet, please restart the bot with /start command."
               )

           return ConversationHandler.END

       except Exception as e:
           logger.error(f"Error in handle_result_buttons: {e}", exc_info=True)
           await query.message.reply_text("An error occurred. Please try again /start")
           return ConversationHandler.END

# –ü—Ä–æ—Å—Ç–∏–π —Ç–µ—Å—Ç–æ–≤–∏–π –æ–±—Ä–æ–±–Ω–∏–∫ –∫–æ–º–∞–Ω–¥–∏ –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Ä–æ–±–æ—Ç–∏ –±–æ—Ç–∞
async def test_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
   print("TEST START COMMAND RECEIVED")
   logger.info("Test start command received")
   await update.message.reply_text("Bot is working! Test response.")

# –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –æ–±—Ä–æ–±–∫–∏ —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
   await update.message.reply_text(
       "Operation cancelled. To start again, use /start command"
   )
   return ConversationHandler.END

# –û–±—Ä–æ–±–Ω–∏–∫ –ø–æ–º–∏–ª–æ–∫
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
   logger.error(f"Error occurred: {context.error}")
   try:
       if update and isinstance(update, Update) and update.effective_message:
           await update.effective_message.reply_text(
               "An error occurred during the command execution. Please try again /start"
           )
   except Exception as e:
       logger.error(f"Error while handling error: {e}")

###########################################
# Main Code
###########################################

def main():
   """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –∑ Web3 —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—î—é - –¥–µ–º–æ-—Ä–µ–∂–∏–º –¥–ª—è —Ö–∞–∫–∞—Ç–æ–Ω—É"""
   print("Starting main() function")

   try:
       # –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ö–µ–º–∏ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö –¥–ª—è –ø—ñ–¥—Ç—Ä–∏–º–∫–∏ Web3
       print("Simulating database schema updates...")
       users_success, users_message = update_user_schema()
       results_success, results_message = update_results_schema()

       print(f"User update: {users_success}, {users_message}")
       print(f"Results update: {results_success}, {results_message}")

       # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –µ–∫–∑–µ–º–ø–ª—è—Ä–∞ –±–æ—Ç–∞
       print("Creating bot in demo mode...")
       bot_handler = HealthTestBot(TOKEN)

       # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è application
       application = ApplicationBuilder().token(TOKEN).build()

       # –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –µ–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
       bot_handler.set_bot(application.bot)

       # –î–æ–¥–∞–≤–∞–Ω–Ω—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –æ–±—Ä–æ–±–Ω–∏–∫–∞
       application.add_handler(CommandHandler('test', test_start))

       # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –æ–±—Ä–æ–±–Ω–∏–∫–∞ —Ä–æ–∑–º–æ–≤–∏ –∑ –¥–æ–¥–∞–≤–∞–Ω–Ω—è–º Web3 —Å—Ç–∞–Ω—ñ–≤
       print("Creating ConversationHandler...")
       conv_handler = ConversationHandler(
           entry_points=[CommandHandler('start', bot_handler.start)],
           states={
               WALLET_VERIFICATION: [
                   CallbackQueryHandler(bot_handler.handle_wallet_callback)
               ],
               WALLET_ADDRESS: [
                   MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.handle_wallet_address),
                   CallbackQueryHandler(bot_handler.handle_wallet_callback)
               ],
               WALLET_SIGNATURE: [
                   MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.verify_transaction)
               ],
               NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.handle_name)],
               AGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.handle_age)],
               GENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.handle_gender)],
               BODY_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.handle_body_type)],
               HEIGHT: [MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.handle_height)],
               WEIGHT: [MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.handle_weight)],
               PROCESSING: [MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.process_results)],
               RESULTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handler.show_results)],
               HORMONE_MENU: [MessageHandler(filters.TEXT & ~filters.COMMAND, lambda update, context: cancel(update, context))],
           },
           fallbacks=[CommandHandler('cancel', cancel)]
       )

       # –î–æ–¥–∞–≤–∞–Ω–Ω—è –æ–±—Ä–æ–±–Ω–∏–∫—ñ–≤
       print("Adding handlers...")
       application.add_handler(conv_handler)
       application.add_handler(CallbackQueryHandler(bot_handler.handle_result_buttons))
       application.add_error_handler(error_handler)

       # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –∑ —è–≤–Ω–∏–º timeout
       print("Starting bot in demo mode...")
       logger.info("Starting Men's Health Test Bot with Web3 integration...")
       application.run_polling(timeout=30, poll_interval=1.0)
   except Exception as e:
       print(f"Critical error in main(): {e}")
       import traceback
       traceback.print_exc()

if __name__ == "__main__":
   try:
       print("Starting program...")
       main()
   except Exception as e:
       print(f"CRITICAL ERROR: {str(e)}")
       import traceback
       traceback.print_exc()
